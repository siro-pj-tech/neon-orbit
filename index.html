<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Orbit - Classic Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            touch-action: manipulation;
        }
        canvas { display: block; }
        .overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 50; backdrop-filter: blur(15px);
            color: white;
            transition: opacity 0.5s;
        }
        .hidden { opacity: 0; pointer-events: none; }
        .btn {
            background: linear-gradient(135deg, #00f2ff, #0077ff);
            color: white; padding: 16px 40px; border-radius: 50px;
            font-weight: 800; font-size: 1.25rem; cursor: pointer;
            transition: all 0.2s; box-shadow: 0 0 20px rgba(0, 242, 255, 0.4);
            border: none; text-transform: uppercase; letter-spacing: 2px;
            margin-top: 20px;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 0 30px rgba(0, 242, 255, 0.6); }
        .btn:active { transform: scale(0.95); }
        .neon-glow { text-shadow: 0 0 10px rgba(0, 242, 255, 0.8), 0 0 20px rgba(0, 242, 255, 0.5); }
        
        #ui-layer { transition: opacity 0.3s; }

        /* ボーナス演出用のスタイル */
        .bonus-feedback {
            position: absolute;
            color: #ffff00;
            font-weight: 900;
            font-size: 1.5rem;
            pointer-events: none;
            z-index: 20;
            text-shadow: 0 0 10px rgba(255, 255, 0, 0.8);
            animation: floatUpFade 0.8s ease-out forwards;
        }

        @keyframes floatUpFade {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
    </style>
</head>
<body>

    <div id="ui-layer" class="absolute top-0 left-0 w-full p-6 flex flex-col items-center pointer-events-none z-10">
        <div id="score-container" class="relative text-center">
            <h1 id="score-display" class="text-7xl font-black neon-glow text-white italic leading-tight">0</h1>
            <div class="flex gap-4 justify-center items-center mt-2">
                <p id="level-display" class="text-xs font-bold text-cyan-400 uppercase tracking-widest bg-cyan-950/50 px-3 py-1 rounded-full border border-cyan-800">Level 1</p>
                <p id="density-display" class="text-xs font-bold text-yellow-400 uppercase tracking-widest bg-yellow-950/50 px-3 py-1 rounded-full border border-yellow-800">1 Enemy / Orbit</p>
            </div>
        </div>
        <div class="absolute right-6 top-6 text-right">
            <p class="text-[8px] uppercase text-gray-500 tracking-widest">Global Best</p>
            <p id="best-display" class="text-xl font-bold text-gray-400">0</p>
        </div>
    </div>

    <!-- スタート画面 -->
    <div id="start-screen" class="overlay">
        <h1 class="text-7xl font-black mb-1 italic text-white neon-glow">NEON ORBIT</h1>
        <p class="text-cyan-400 font-bold mb-12 uppercase tracking-[0.4em] text-xs">The Pure Reflex Experience</p>
        
        <div class="text-center mb-8 max-w-xs space-y-4">
            <p class="text-gray-300 text-sm leading-relaxed">
                タップで軌道を切り替えろ。<br>
                移動の「中盤」だけ敵をすり抜けられる。<br>
                スコアに応じて敵が追加される（点滅中は安全）。<br>
                <span class="text-yellow-400 font-bold">黄色い円はボーナス！スコアが大幅アップ。</span>
            </p>
        </div>

        <button id="start-btn" class="btn">Launch Mission</button>
    </div>

    <!-- ゲームオーバー画面 -->
    <div id="gameover-screen" class="overlay hidden">
        <h2 class="text-xs font-black mb-4 text-red-500 uppercase tracking-[1em]">Mission Failed</h2>
        <div class="flex flex-col items-center mb-10">
            <p id="final-score" class="text-8xl font-black text-white italic mb-2">0</p>
            <p id="new-record-msg" class="text-yellow-400 font-bold hidden animate-bounce tracking-widest text-sm uppercase">New High Score!</p>
        </div>
        <button id="restart-btn" class="btn text-white">Retry Mission</button>
    </div>

    <canvas id="gameCanvas"></canvas>

    <script>
        class SoundEngine {
            constructor() { this.ctx = null; }
            init() { 
                if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.ctx.state === 'suspended') this.ctx.resume();
            }
            playBeat(time) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(120, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.12);
                gain.gain.setValueAtTime(0.15, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.12);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(time); osc.stop(time + 0.12);
            }
            playCollect() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.frequency.setValueAtTime(900, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1800, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.1);
            }
            playExplosion() {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(40, this.ctx.currentTime + 0.4);
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.4);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.4);
            }
        }

        const sound = new SoundEngine();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        const scoreContainer = document.getElementById('score-container');
        const levelDisplay = document.getElementById('level-display');
        const densityDisplay = document.getElementById('density-display');
        const bestDisplay = document.getElementById('best-display');
        const startScreen = document.getElementById('start-screen');
        const gameoverScreen = document.getElementById('gameover-screen');
        const finalScoreText = document.getElementById('final-score');
        const newRecordMsg = document.getElementById('new-record-msg');

        let width, height, centerX, centerY;
        let gameState = 'START';
        let score = 0;
        let currentLevel = 1;
        let enemiesPerOrbit = 1;
        let highScore = localStorage.getItem('neonOrbitBest') || 0;
        bestDisplay.innerText = highScore;

        const ORBIT_RADII = [80, 140, 200];
        const PLAYER_SIZE = 14;
        const ENEMY_SIZE = 16;
        const ITEM_SIZE = 12;
        const MOVE_COOLDOWN = 300; 
        
        let player = {
            targetOrbitIndex: 1,
            angle: 0,
            speed: 0.03,
            color: '#00f2ff',
            currentRadius: ORBIT_RADII[1],
            isTransitioning: false,
            isInvincible: false,
            lastMoveTime: 0,
            x: 0, y: 0
        };

        let enemies = [];
        let items = [];
        let particles = [];
        let frameCount = 0;
        let lastBeatTime = 0;

        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
            centerX = width / 2; centerY = height / 2;
        }
        window.addEventListener('resize', resize);
        resize();

        class Particle {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.size = Math.random() * 3 + 2;
                const ang = Math.random() * Math.PI * 2;
                const vel = Math.random() * 5 + 2;
                this.vx = Math.cos(ang) * vel; this.vy = Math.sin(ang) * vel;
                this.life = 1.0; this.decay = 0.03;
            }
            update() { this.x += this.vx; this.y += this.vy; this.life -= this.decay; }
            draw() {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        class Enemy {
            constructor(orbitIndex, startAngle, dirSign, warning = false) {
                this.orbitIndex = orbitIndex;
                this.radius = ORBIT_RADII[orbitIndex];
                this.angle = startAngle;
                this.dirSign = dirSign;
                this.speed = 0;
                this.color = '#ff3366';
                this.speedModOffset = Math.random() * Math.PI * 2;
                this.warningFrames = warning ? 60 : 0; 
            }
            update() {
                if (this.warningFrames > 0) {
                    this.warningFrames--;
                } else {
                    const baseSpeed = 0.02 + (currentLevel * 0.003);
                    if (this.orbitIndex === 1) {
                        const modulation = Math.sin(frameCount * 0.02 + this.speedModOffset) * 0.015;
                        this.speed = (baseSpeed + 0.01 + modulation) * this.dirSign;
                    } else {
                        this.speed = (baseSpeed + 0.01) * this.dirSign;
                    }
                    this.angle += this.speed;
                }
                this.x = centerX + Math.cos(this.angle) * this.radius;
                this.y = centerY + Math.sin(this.angle) * this.radius;
            }
            draw() {
                if (this.warningFrames > 0) {
                    if (Math.floor(this.warningFrames / 6) % 2 === 0) return;
                }
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 15; ctx.shadowColor = this.color;
                ctx.beginPath(); ctx.arc(this.x, this.y, ENEMY_SIZE, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0;
            }
        }

        function spawnEnemyForOrbit(orbit, useWarning = false) {
            let startAngle;
            let attempts = 0;
            do {
                startAngle = Math.random() * Math.PI * 2;
                let diff = startAngle - player.angle;
                let normDiff = ((diff + Math.PI) % (Math.PI * 2)) - Math.PI;
                if (Math.abs(normDiff) > 1.8) break;
                attempts++;
            } while (attempts < 30);

            let dirSign;
            const currentCountInOrbit = enemies.filter(e => e.orbitIndex === orbit).length;
            if (currentCountInOrbit === 0) {
                dirSign = (orbit === 2) ? -1 : 1;
            } else {
                dirSign = (currentCountInOrbit % 2 === 0) ? 1 : -1;
            }
            enemies.push(new Enemy(orbit, startAngle, dirSign, useWarning));
        }

        function initEnemies() {
            enemies = [];
            for (let orbit = 0; orbit < 3; orbit++) {
                for (let i = 0; i < enemiesPerOrbit; i++) {
                    spawnEnemyForOrbit(orbit, false);
                }
            }
        }

        function initGame() {
            score = 0; currentLevel = 1; enemiesPerOrbit = 1; frameCount = 0;
            items = []; particles = [];
            player.targetOrbitIndex = 1; player.currentRadius = ORBIT_RADII[1]; player.angle = 0;
            player.isTransitioning = false; player.isInvincible = false; player.lastMoveTime = 0;
            
            initEnemies();
            updateUIDisplay();
            newRecordMsg.classList.add('hidden');
        }

        function updateUIDisplay() {
            scoreDisplay.innerText = Math.floor(score);
            levelDisplay.innerText = `Level ${currentLevel}`;
            densityDisplay.innerText = `${enemiesPerOrbit} Enemy / Orbit`;
        }

        function showBonusEffect() {
            const feedback = document.createElement('div');
            feedback.className = 'bonus-feedback';
            feedback.innerText = '+Bonus';
            const rect = scoreContainer.getBoundingClientRect();
            feedback.style.left = `${rect.left + rect.width / 2 + (Math.random() * 40 - 20)}px`;
            feedback.style.top = `${rect.top - 20}px`;
            document.body.appendChild(feedback);
            setTimeout(() => { feedback.remove(); }, 800);
        }

        function gameOver() {
            gameState = 'GAMEOVER';
            sound.playExplosion();
            gameoverScreen.classList.remove('hidden');
            finalScoreText.innerText = Math.floor(score);
            if (score > highScore) {
                highScore = Math.floor(score);
                localStorage.setItem('neonOrbitBest', highScore);
                bestDisplay.innerText = highScore;
                newRecordMsg.classList.remove('hidden');
            }
            for (let i = 0; i < 40; i++) particles.push(new Particle(player.x, player.y, player.color));
        }

        function handleInput() {
            if (gameState === 'PLAYING') {
                const now = Date.now();
                if (now - player.lastMoveTime < MOVE_COOLDOWN) return;
                player.targetOrbitIndex = (player.targetOrbitIndex + 1) % 3;
                player.lastMoveTime = now;
            }
        }

        window.addEventListener('mousedown', (e) => { 
            if (!e.target.closest('.btn')) { sound.init(); handleInput(); } 
        });
        window.addEventListener('touchstart', (e) => { 
            if (!e.target.closest('.btn')) { sound.init(); handleInput(); e.preventDefault(); } 
        }, { passive: false });

        document.getElementById('start-btn').onclick = () => {
            sound.init();
            gameState = 'PLAYING';
            initGame();
            startScreen.classList.add('hidden');
        };

        document.getElementById('restart-btn').onclick = () => {
            gameoverScreen.classList.add('hidden');
            startScreen.classList.remove('hidden');
            gameState = 'START';
        };

        function animate() {
            ctx.fillStyle = 'rgba(2, 2, 5, 0.4)';
            ctx.fillRect(0, 0, width, height);

            ORBIT_RADII.forEach((r, i) => {
                ctx.strokeStyle = player.targetOrbitIndex === i ? 'rgba(0, 242, 255, 0.4)' : 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = player.targetOrbitIndex === i ? 4 : 1;
                ctx.beginPath(); ctx.arc(centerX, centerY, r, 0, Math.PI * 2); ctx.stroke();
            });

            if (gameState === 'PLAYING' || gameState === 'GAMEOVER') {
                if (gameState === 'PLAYING') {
                    score += 0.25;
                    frameCount++;
                    
                    let prevEnemies = enemiesPerOrbit;
                    if (score > 2500) enemiesPerOrbit = 3;
                    else if (score > 1000) enemiesPerOrbit = 2;
                    else enemiesPerOrbit = 1;

                    if (prevEnemies !== enemiesPerOrbit) {
                        currentLevel++;
                        for (let orbit = 0; orbit < 3; orbit++) {
                            spawnEnemyForOrbit(orbit, true);
                        }
                    }
                    updateUIDisplay();

                    if (sound.ctx && sound.ctx.currentTime - lastBeatTime > 0.5) {
                        sound.playBeat(sound.ctx.currentTime);
                        lastBeatTime = sound.ctx.currentTime;
                    }

                    if (frameCount % 500 === 0) {
                        items.push({ orbitIndex: Math.floor(Math.random()*3), angle: player.angle + Math.PI });
                    }

                    player.angle += player.speed + (currentLevel * 0.001);
                    let targetR = ORBIT_RADII[player.targetOrbitIndex];
                    const distToTarget = Math.abs(targetR - player.currentRadius);
                    player.isTransitioning = distToTarget > 1.0;
                    player.isInvincible = player.isTransitioning && distToTarget < 45 && distToTarget > 5;

                    player.currentRadius += (targetR - player.currentRadius) * 0.18;
                    player.x = centerX + Math.cos(player.angle) * player.currentRadius;
                    player.y = centerY + Math.sin(player.angle) * player.currentRadius;
                }

                ctx.fillStyle = player.color; 
                ctx.shadowBlur = player.isInvincible ? 40 : 20; 
                ctx.shadowColor = player.color;
                if (player.isInvincible) ctx.globalAlpha = 0.4;
                ctx.beginPath(); ctx.arc(player.x, player.y, PLAYER_SIZE, 0, Math.PI * 2); ctx.fill();
                ctx.globalAlpha = 1.0; ctx.shadowBlur = 0;
                
                enemies.forEach(e => {
                    e.update(); e.draw();
                    if (!player.isInvincible && e.warningFrames === 0 && gameState === 'PLAYING') {
                        let dist = Math.hypot(player.x - e.x, player.y - e.y);
                        if (dist < PLAYER_SIZE + ENEMY_SIZE - 7) gameOver();
                    }
                });

                for (let i = items.length - 1; i >= 0; i--) {
                    let it = items[i];
                    let ix = centerX + Math.cos(it.angle) * ORBIT_RADII[it.orbitIndex];
                    let iy = centerY + Math.sin(it.angle) * ORBIT_RADII[it.orbitIndex];
                    ctx.fillStyle = '#ffff00'; ctx.shadowBlur = 20; ctx.shadowColor = '#ffff00';
                    ctx.beginPath(); ctx.arc(ix, iy, ITEM_SIZE, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
                    if (gameState === 'PLAYING' && Math.hypot(player.x - ix, player.y - iy) < PLAYER_SIZE + ITEM_SIZE + 5) {
                        score += 500; 
                        sound.playCollect();
                        showBonusEffect();
                        for (let p=0; p<15; p++) particles.push(new Particle(ix, iy, '#ffff00'));
                        items.splice(i, 1);
                    }
                }

                for (let i = particles.length - 1; i >= 0; i--) {
                    particles[i].update(); particles[i].draw();
                    if (particles[i].life <= 0) particles.splice(i, 1);
                }
            }
            requestAnimationFrame(animate);
        }

        window.onload = animate;
    </script>
</body>
</html>